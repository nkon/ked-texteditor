# KED : simple TUI(Terminal User Interface) text editor for rust training.

コロナウイルスで自宅に閉じ込められてしまったので、プログラミングの練習のためにテキストエディタを作ってみよう。

## 目標としている機能・実装

* 練習・教材用として十分な小ささ。

記事のネタになる。また、作っていて飽きない。ひと篭もりするプロジェクトとしててきせつなサイズ。

昔から、プログラマなら作ってみたいもの。(1)コンパイラ (2))OS (3)エディタ。コンパイラについては以前に書いた。

* ターミナル上で普通に使えるテキストエディタ。
* 日本語変換機能を自前で持つ（それも書いてみたい）。
* 移植性があること。Linux、Windowsターミナル、RaspberryPiのターミナルで同様に動作する。

これら3つの特徴によって、どこに持って行っても最低限のテキストファイル編集機能が手に入る。標準の開発環境はUbuntuだが、muslなどを使って、macOS、Windows、Windows(MSL)、RaspberryPiなどの環境で、COPY&RUNの環境が便利だと思っている。

日本語変換機能については、技術的な興味が大きいこと。また、AIの業務応用としてどれだけの成果を上げられるのかに興味があることから実装してみようと思う。


* 設定変更機能を持つ（そういったものをハードコーディングせずにインタプリタ化する）。
* キーボードマクロを持つ。自動化テストにも役に立つだろう。。

## 実装上のポイント

テキストエディタを実装する時は、常に話題となるような事柄がいくつある。

### RAWモード

用語の定義として、CUI=コマンド・ユーザ・インターフェイス。シェルのプロンプトにコマンドやオプション列を入力して、結果が帰ってくるもの。TUI=ターミナル・ユーザ・インターフェイス。ターミナル上で動作するが、viなどのようにターミナルの全画面を使ってインタラクティブに操作するアプリケーション。

現状を見ていると、DockerやSSH経由などでのヘッドレス環境、WSLのようなターミナルがメインの環境が増えてくる。VS Codeのリモート開発的なものも活用されるだろう。しかし、簡易的には、そういった環境ではTUIが、環境の制約と操作性を両立するために便利だ。GUIだとWidgetの制約があったりして、大きくて移植性がないことが多い。TUIはエスケープ・シーケンスを元にしているので、小さくて移植性がいいのも良い。

TUIアプリケーションの基礎となるのが、ターミナルが解釈するエスケープシーケンスだ。特殊な文字列を出力することによって端末をコントロールすることができる。Cでは`curses`、それの派生である`ncuurse`、`termio`というライブラリが有名である。Rustで使えるTUIライブラリを調べた。termionはわりと薄く、動作を理解しやすわりに依存ライブラリが無くてPure Rustだ。今回はこれを選定した。

[termion](https://github.com/redox-os/termion)

端末をRAWモードにすれば、キー入力に対するエコーバックや改行入力の特別扱いがなくなり、アプリケーションでキー入力を直接ハンドリングすることができる。出力も、エコーバックが無くなるのでアプリケーションから自前で制御しなければならない。文字出力だけでなくエスケープシーケンスを出力することで、カーソル移動、色の変更などもできる。アプリ終了時にはCOOKEDモードに戻してあげよう。

基本的にはこれだけでTUIアプリケーションを作ることができる。

### 表示ウィンドウ

エスケープ・シーケンスは端末の左上を(1,1)とした座標で動作する。一方、TUI上にはメインの表示領域の他にステータスバーや、ポップアップなどを出したくなるだろう。端末全体をルート・ウィンドウとしたうえで、子ウインドウを定義して、システマチックに座標計算できるようにしておいたほうが便利だろう。

### バッファーの持ち方

テキストエディタの基本概念は次のようなものになるだろう。

* ファイルをバッファに展開し、バッファに対して操作をし、バッファほファイルに保存する。ただし、ファイルと関連付けられないバッファも存在する。
* バッファに対する操作点はカーソルと言われる。カーソルを移動したり、カーソル位置に文字を挿入したり、カーソル位置の文字を削除したり。
* エディタは複数のバッファを持つことができる。

バッファの実装方法としてはいくつか提案されている。メモリ操作が十分に大きくて早ければどれを選んでも良い。しかし、巨大な、しばしばメモリに収まりきらないような大きなファイルを編集する時には、速度に関するトレードオフが発生するのでさまざまなデータ構造が考案されてきた。

* 行リスト
* Gap Buffer
* Rope

簡易的にはツールキットのテキストウィジェットを使えば、テキストエディタは簡単に実装できる。しかし、その内側では適切な実装を工夫しているのだ。

今回の実装は行リストで行った。しかし、バッファへの編集操作が抽象化されていれば、性能に問題が発生した場合に実装を入れ替えることが可能となる。

#### 行リスト

代表的な実装例はvi。

「バッファは行が集まったもの」として実装される。行は一般的には文字の配列または文字列だ。

バッファ全体は行（へのポインタ:行のサイズは不定なので）の配列としても良い。しかし、配列ではなく、行をダブル・リンクド・リストで繋げていったほうが、編集対象が大きい場合に挿入のコストが安い。

表示構造と実装構造が対応しているのでわかりやすい。しかし、ファイルの読み書き動作が行ごとになるので、行数が多いと重くなりがちだ。

コレ以外の実装は、この行リストではダメだから考え出されたもの。行リストで不自由しなければ、行リストでよい。

#### Gap Buffer

代表的な実装例はEmacs。

行を意識せずに、ファイル全体をメモリブロックに割りつける。ただしメモリブロックの大きさはファイル全体よりも大きい。カーソルがある所で、ファイル全体を2つに分けて、カーソルより前の部分をメモリブロックの前半に、カーソルより後の部分をメモリブロックの後半に割り当てる。カーソルの所にはファイルが割当たっていないギャップができる。

こうすることで、エディタにおいてもっとも頻繁に行われる「文字の挿入」はギャップの前端（前半のブロックの後端）に文字を追加するだけなので、非常に低コストで行うことができる。カーソルが移動した時は、その後に入力などの操作をする時に、移動した分のテキストブロックを、後半⇔前半で移動すればよい。これも比較的軽い。

「頻繁な操作は軽く、希な操作は重くても良い」というトレード・オフを具現化したデータ構造。プログラミング初心者のころに雑誌の記事で読んで、感心した記憶がある。

#### Rope

代表例はVS Code。

一端書かれたものは不変で、追記型のデータ構造。StringではなくてRopeということらしい。

巨大なデータをハンドリングすることができる。

最初、ファイルは1つの塊としてメモリに割り当てられる。バッファの途中に挿入した時は、別のメモリを割り当て、挿入前半〜新規挿入部分〜挿入後半、のように別々のメモリをつなぎ合わせる形になる。これをテーブルで管理すればPiece Table、ツリーで管理すればRopeということ。

追記型なので、物理メモリではなく仮想メモリに割り当てておけば巨大ファイルも編集可能になるのだろうか。書き込み単位ごとにメモリ小片ができあがるのでUndoとの相性が良さそうだ。小片ごとに属性（構文ハイライトなど）も付けやすいというメリットもあるかもしれない。

## Rustプロジェクトのディレクトリ構造

これも、ほとんど標準化されている。

```
ked/
+ Cargo.toml
+ Cargo.lock
+ readme.md
+ src/
    + main.rs     バイナリクレートの起点。mainを含む。
    + lib.rs      テストしやすいようにするために、main.rs からモジュールを切り出し、lib.rsでまとめてライブラリとして扱えるようにする。
    + XXXXXXX.rs  個々のモジュール
+ tests/          結合テスト用のディレクトリ。
+ target/   コンパイラの生成物。.gitignore される。
    + 
```

## 日本語の取り扱い

### 表示（UTF-8）

### IME

## 開発の進め方

### ビルドアップスタイル

### 開発環境

VS Codeの上で開発したのだが、非常に便利。

* 編集中に文法エラーがあると赤の波線で指定してくれる。マウスカーソルを合わせると、エラー原因と対策が表示されるので、それに合わせて修正する。
* 問題リストがクリアになったら`cargo run`。
* Rustは、フォーマット、命名規則、コメントの書き方などのコーディングルールが公式で決まっていて、ツールもサポートされている。「自転車置き場な議論」の余地なく、最良のプラクティスが手に入る。

* VS CodeにはGitが統合されているので、こまめにコミットする作業が苦にならない。

* LLDBなどのデバッガは使わなかった。printfデバッグをメイン。

* 日本語のメモは「テキスト校正くん」という拡張で、即時訂正しながら。読みやすい文章にしたい。

## アーキテクチャの設計

APIは実装＆リファクタリングを進めていくうえで、自然に整理されていくだろう。しかし、一度も経験がないままで、このようなAPIを構築できるだろうか。結果から見れば当然と思うようなAPI集であっても、実装していく中で、抜け漏れの発見や引数の調整などが頻発する。

インクリメンタルな開発と実装優先順位のトレードオフのような上位設計川から見ても、実装＆テストでの抜け漏れから見ても、実装能力を持たない管理者によるウォーターフローモデルの破綻は明らかだと思う。あまり、実感として理解されていないように思うが。

## テスト

エディタはコーナーケースが多い。
自動化テストを行いたい。
ユニットテスト（内部）と結合テスト（外部）。ユニットテストはrustの標準機能を活用。結合テストのためにはマクロ機能が必要。

### ユニットテスト

Rustの言語機能に依存する部分が多いが、適切なAPI化やテストハーネスを使えば、Cでも同等のことはできるはずだ。

### 結合テスト

言語レベルで統合テストはサポートされていない。統合テストを実施するための、アーキテクチャ設計が必要だ。本プログラムではマクロ機能。ユーザ機能としても使えるがテストに使いやすいように、というのが設計の主眼だ。APIもそれに合わせて設計される。


## log

開発経緯については、GitHubのコミットログを参照していただきたい。その中でもマイルストーンとなるコミットについては[log.md](log.md) に記録しておく。これは実作業の記録なので、まとめとしては、この文書のほうがまとまっている。ビルドアップスタイルを追体験したいなら、コミットをたどっていってもおもしろいかもしれない。

[log.mg](log.md)

